#############################################
# CATEGORY: app.controller.spec.ts
# TYPE: OTHER
# FILE: app.controller.spec.ts
# CLASS: Unknown
#############################################

import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});


#############################################
# CATEGORY: auth
# TYPE: OTHER
# FILE: login.dto.ts
# CLASS: LoginDto
#############################################

import { IsEmail, IsNotEmpty } from 'class-validator';

export class LoginDto {
  @IsEmail()
  email: string;

  @IsNotEmpty()
  password: string;
}


#############################################
# CATEGORY: auth
# TYPE: OTHER
# FILE: register.dto.ts
# CLASS: RegisterDto
#############################################

import { IsEmail, IsNotEmpty, MinLength } from 'class-validator';

export class RegisterDto {
  @IsEmail()
  email: string;

  @IsNotEmpty()
  @MinLength(6)
  password: string;

  @IsNotEmpty()
  name: string;
}


#############################################
# CATEGORY: auth
# TYPE: OTHER
# FILE: jwt-access.guard.ts
# CLASS: JwtAccessGuard
#############################################

import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAccessGuard extends AuthGuard('jwt-access') {}


#############################################
# CATEGORY: auth
# TYPE: OTHER
# FILE: jwt-access.strategy.ts
# CLASS: JwtAccessStrategy
#############################################

import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { Request } from 'express';

@Injectable()
export class JwtAccessStrategy extends PassportStrategy(Strategy, 'jwt-access') {
  constructor(config: ConfigService) {
    super({
      jwtFromRequest: ExtractJwt.fromExtractors([
        // ① Cookie から取得（ブラウザ用）
        (req: Request) => {
          if (!req || !req.cookies) return null;
          return req.cookies['access_token'] || null;
        },
        // ② Authorization: Bearer から取得（curl / APIクライアント用）
        ExtractJwt.fromAuthHeaderAsBearerToken(),
      ]),
      secretOrKey: config.get<string>('JWT_ACCESS_SECRET'),
    });
  }

  async validate(payload: any) {
    // ここで返したオブジェクトが req.user に入る
    return payload;
  }
}


#############################################
# CATEGORY: auth
# TYPE: OTHER
# FILE: jwt-refresh.strategy.ts
# CLASS: JwtRefreshStrategy
#############################################

import { Injectable, UnauthorizedException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';

@Injectable()
export class JwtRefreshStrategy extends PassportStrategy(Strategy, 'jwt-refresh') {
  constructor(private readonly configService: ConfigService) {
    super({
      jwtFromRequest: ExtractJwt.fromExtractors([
        (req: any) => req?.cookies?.['refresh_token'],
      ]),
      ignoreExpiration: false,
      secretOrKey: configService.get<string>('JWT_REFRESH_SECRET'),
    });
  }

  async validate(payload: any) {
    if (!payload?.sub) throw new UnauthorizedException();
    return payload;
  }
}


#############################################
# CATEGORY: constants
# TYPE: OTHER
# FILE: kycMessages.ts
# CLASS: Unknown
#############################################

export const KYC_MESSAGE_MAP = {
  1: {
    title: "本人確認申請ありがとうございます",
    body: "本人確認書類のご提出ありがとうございます。\n現在、確認作業を行っております。\n完了まで今しばらくお待ちください。"
  },

  2: {
    title: "本人確認書類の再提出のお願い",
    body: "ご提出いただいた本人確認書類に不備がありました。\n内容をご確認のうえ、正しい書類を再度ご提出ください。"
  },

  3: {
    title: "住所確認書類の再提出のお願い",
    body: "ご提出いただいた住所確認書類に不備がありました。\n内容をご確認のうえ、正しい書類を再度ご提出ください。"
  },

  // 4: 追加認証書類再提出（将来用）

  5: {
    title: "本人確認完了のお知らせ",
    body: "本人確認が完了しました。\nこれよりすべての機能をご利用いただけます。"
  }
} as const;


#############################################
# CATEGORY: constants
# TYPE: OTHER
# FILE: transferMessages.ts
# CLASS: Unknown
#############################################

export const DEPOSIT_REQUEST_MESSAGE = {
  title: "入金申請ありがとうございます",
  body: "入金申請を受け付けました。\n着金確認後、取引口座へ反映されます。"
} as const;

export const DEPOSIT_COMPLETED_MESSAGE = {
  title: "入金完了のお知らせ",
  body: "入金の確認が取れました。\n取引口座へ残高を反映しました。"
} as const;

export const WITHDRAW_REQUEST_MESSAGE = {
  title: "出金申請を受け付けました",
  body: "出金申請を受け付けました。\n処理を開始しましたので、完了まで今しばらくお待ちください。"
} as const;


#############################################
# CATEGORY: main.ts
# TYPE: OTHER
# FILE: main.ts
# CLASS: Unknown
#############################################

import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import * as cookieParser from 'cookie-parser';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // Cookie を扱えるようにする
  app.use(cookieParser());

  // CORS は Nginx 側で処理するため、NestJS では設定しない

  await app.listen(3000);
  console.log('API running on port 3000');
}

bootstrap();


#############################################
# CATEGORY: user-extra
# TYPE: OTHER
# FILE: save-bank.dto.ts
# CLASS: SaveBankDto
#############################################

export class SaveBankDto {
  bankName: string;
  branchName?: string;
  accountType?: string;
  accountNumber?: string;
  accountHolder?: string;
}


#############################################
# CATEGORY: user-extra
# TYPE: OTHER
# FILE: save-crypto.dto.ts
# CLASS: SaveCryptoDto
#############################################

import { IsArray, ValidateNested, IsString } from "class-validator";
import { Type } from "class-transformer";

class CryptoAddressDto {
  @IsString()
  currency: string;

  @IsString()
  address: string;
  memoTag?: string | null;
}

export class SaveCryptoDto {
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => CryptoAddressDto)
  addresses: CryptoAddressDto[];
}





