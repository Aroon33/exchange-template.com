#############################################
# CATEGORY: app.service.ts
# TYPE: SERVICE
# FILE: app.service.ts
# CLASS: AppService
#############################################

import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}


#############################################
# CATEGORY: auth
# TYPE: SERVICE
# FILE: auth.service.ts
# CLASS: AuthService
#############################################

import {
  BadRequestException,
  Injectable,
  UnauthorizedException,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';
import * as bcrypt from 'bcryptjs';
import { UsersService } from '../users/users.service';
import { UserRole } from '@prisma/client';
import { RegisterDto } from './dto/register.dto';
import { LoginDto } from './dto/login.dto';

@Injectable()
export class AuthService {
  constructor(
    private readonly usersService: UsersService,
    private readonly jwtService: JwtService,
    private readonly config: ConfigService,
  ) {}

  /** æ–°è¦ç™»éŒ² */
  async register(dto: RegisterDto) {
    const existing = await this.usersService.findByEmail(dto.email);
    if (existing) {
      throw new BadRequestException('Email already in use');
    }

    const hash = await bcrypt.hash(dto.password, 10);

    const user = await this.usersService.createUser({
      email: dto.email,
      password: hash,
      name: dto.name,
      role: UserRole.USER,
    });

    return {
      id: user.id,
      email: user.email,
      name: user.name,
      role: user.role,
    };
  }

  /** ãƒ­ã‚°ã‚¤ãƒ³ */
  async login(dto: LoginDto) {
    const user = await this.usersService.findByEmail(dto.email);
    if (!user) {
      throw new UnauthorizedException('Invalid credentials');
    }

    const ok = await bcrypt.compare(dto.password, user.password);
    if (!ok) {
      throw new UnauthorizedException('Invalid credentials');
    }

    const payload = {
      sub: user.id,
      email: user.email,
      role: user.role,
      groupId: user.group?.id ?? undefined,
      name: user.name,

    };

    // expires
    const accessExpiresIn = this.config.get<string>('JWT_ACCESS_EXPIRES_IN') ?? '15m';
    const refreshExpiresIn = this.config.get<string>('JWT_REFRESH_EXPIRES_IN') ?? '7d';

    const access = await this.jwtService.signAsync(payload, {
  secret: this.config.get('JWT_ACCESS_SECRET') as string,
  expiresIn: accessExpiresIn as any,
});

const refresh = await this.jwtService.signAsync(payload, {
  secret: this.config.get('JWT_REFRESH_SECRET') as string,
  expiresIn: refreshExpiresIn as any,
});


    

    return {
      access,
      refresh,
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        role: user.role,
        groupId: user.group?.id,
      },
    };
  }
}


#############################################
# CATEGORY: deposit
# TYPE: SERVICE
# FILE: deposit.service.ts
# CLASS: DepositService
#############################################

import {
  BadRequestException,
  Injectable,
} from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import {
  TransferStatus,
  TransferType,
  SenderType,
} from '@prisma/client';
import { Prisma } from '@prisma/client';

@Injectable()
export class DepositService {
  constructor(private readonly prisma: PrismaService) {}

  /* =====================================================
     å…±é€šï¼šCRYPTO ã‚¢ãƒ‰ãƒ¬ã‚¹å‰²å½“ + ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹é·ç§» + ãƒãƒ£ãƒƒãƒˆ
     â€» å¿…ãšãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å†…ã§å‘¼ã¶
  ===================================================== */
  private async assignCryptoAddressAndSendMessage(
    tx: Prisma.TransactionClient,
    transfer: any,
  ) {
    if (!transfer.currency) {
      throw new BadRequestException('Currency missing');
    }

    // ğŸ”’ æœªä½¿ç”¨ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ãƒ­ãƒƒã‚¯å–å¾—
    const rows = await tx.$queryRaw<any[]>`
      SELECT *
      FROM deposit_crypto_addresses
      WHERE currency = ${transfer.currency}
        AND used = 0
        AND userId IS NULL
      ORDER BY id ASC
      LIMIT 1
      FOR UPDATE
    `;

    if (!rows.length) {
      throw new BadRequestException(
        `æœªä½¿ç”¨ã® ${transfer.currency} ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒã‚ã‚Šã¾ã›ã‚“`,
      );
    }

    const addr = rows[0];

    // â‘  ã‚¢ãƒ‰ãƒ¬ã‚¹å‰²å½“
    await tx.depositCryptoAddress.update({
      where: { id: addr.id },
      data: {
        used: true,
        userId: transfer.userId,
      },
    });

    // â‘¡ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
    await tx.transfer.update({
      where: { id: transfer.id },
      data: {
        status: TransferStatus.CONFIRMING,
      },
    });

    // â‘¢ ãƒã‚±ãƒƒãƒˆå–å¾— or ä½œæˆ
    let ticket = await tx.ticket.findFirst({
      where: { userId: transfer.userId },
      orderBy: { createdAt: 'desc' },
    });

    if (!ticket) {
      ticket = await tx.ticket.create({
        data: {
          userId: transfer.userId,
          title: 'å…¥é‡‘ã®ã”æ¡ˆå†…',
        },
      });
    }

    // â‘£ ãƒãƒ£ãƒƒãƒˆé€ä¿¡
    await tx.ticketMessage.create({
      data: {
        ticketId: ticket.id,
        sender: SenderType.ADMIN,
        message:
`ã€å…¥é‡‘ç”¨ã‚¢ãƒ‰ãƒ¬ã‚¹ã®ã”æ¡ˆå†…ã€‘

é€šè²¨ï¼š${addr.currency}
ã‚¢ãƒ‰ãƒ¬ã‚¹ï¼š
${addr.address}
${addr.memoTag ? `MEMO / TAGï¼š${addr.memoTag}` : ''}

â€» ã“ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯ä»Šå›ã®å…¥é‡‘å°‚ç”¨ã§ã™ã€‚
â€» ç€é‡‘ç¢ºèªå¾Œã€æ®‹é«˜ã¸åæ˜ ã•ã‚Œã¾ã™ã€‚`,
      },
    });
  }

  /* =====================================================
     ç®¡ç†è€…ï¼šCRYPTO å…¥é‡‘ã‚¢ãƒ‰ãƒ¬ã‚¹å‰²å½“ï¼ˆå˜ä½“å®Ÿè¡Œç”¨ï¼‰
  ===================================================== */
  async assignCryptoAddressAndNotify(transferId: number) {
    return this.prisma.$transaction(async (tx) => {
      const transfer = await tx.transfer.findUnique({
        where: { id: transferId },
      });

      if (!transfer) {
        throw new BadRequestException('Transfer not found');
      }

      if (
        transfer.type !== TransferType.DEPOSIT ||
        transfer.method !== 'CRYPTO' ||
        transfer.status !== TransferStatus.PENDING
      ) {
        throw new BadRequestException('Invalid transfer state');
      }

      await this.assignCryptoAddressAndSendMessage(tx, transfer);

      return { success: true };
    });
  }

  /* =====================================================
     å…¥é‡‘æ‰¿èªï¼ˆADMINï¼‰
     - JPY    : å³ COMPLETED + æ®‹é«˜åæ˜ 
     - CRYPTO : ã‚¢ãƒ‰ãƒ¬ã‚¹å‰²å½“ + CONFIRMING + ãƒãƒ£ãƒƒãƒˆ
  ===================================================== */
  async approveDeposit(transferId: number) {
    return this.prisma.$transaction(async (tx) => {

      /* =====================
         â‘  å…¥é‡‘å–å¾—
      ===================== */
      const transfer = await tx.transfer.findUnique({
        where: { id: transferId },
      });

      if (!transfer) {
        throw new BadRequestException('Transfer not found');
      }

      if (transfer.type !== TransferType.DEPOSIT) {
        throw new BadRequestException('Not a deposit');
      }

      if (transfer.status !== TransferStatus.PENDING) {
        throw new BadRequestException('Invalid status');
      }

      /* =====================
         â‘¡ JPY å…¥é‡‘
      ===================== */
      if (transfer.method === 'JPY') {
        const wallet = await tx.wallet.findUnique({
          where: { userId: transfer.userId },
        });

        if (!wallet) {
          throw new BadRequestException('Wallet not found');
        }

        const amount = Number(transfer.amount);

        await tx.wallet.update({
          where: { userId: transfer.userId },
          data: {
            balanceAvailable: { increment: amount },
            balanceTotal: { increment: amount },
          },
        });

        await tx.transfer.update({
          where: { id: transfer.id },
          data: { status: TransferStatus.COMPLETED },
        });

        return { success: true, type: 'JPY' };
      }

      /* =====================
         â‘¢ CRYPTO å…¥é‡‘
      ===================== */
      if (transfer.method === 'CRYPTO') {
        await this.assignCryptoAddressAndSendMessage(tx, transfer);

        return {
          success: true,
          type: 'CRYPTO',
          status: 'CONFIRMING',
        };
      }

      throw new BadRequestException('Unsupported deposit method');
    });
  }
}


#############################################
# CATEGORY: groups
# TYPE: SERVICE
# FILE: groups.service.ts
# CLASS: GroupsService
#############################################

import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';

@Injectable()
export class GroupsService {
  constructor(private readonly prisma: PrismaService) {}

  async listGroups() {
    return this.prisma.group.findMany({
      orderBy: { id: 'asc' },
      include: { users: true },
    });
  }

  async moveUsersToGroup(groupId: number, userIds: number[]) {
    return this.prisma.$transaction(async (tx) => {
      await tx.user.updateMany({
        where: { id: { in: userIds } },
        data: { groupId },
      });

      return tx.group.findUnique({
        where: { id: groupId },
        include: { users: true },
      });
    });
  }
}


#############################################
# CATEGORY: kyc
# TYPE: SERVICE
# FILE: kyc.service.ts
# CLASS: KycService
#############################################

import { Injectable, BadRequestException, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import * as fs from 'fs';
import * as path from 'path';

@Injectable()
export class KycService {
  constructor(private readonly prisma: PrismaService) {}

  /**
   * ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æœ€æ–°KYCã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å–å¾—
   */
  async getStatus(userId: number) {
    const latest = await this.prisma.kycRequest.findFirst({
      where: { userId },
      orderBy: { createdAt: 'desc' },
    });

    if (!latest) {
      return {
        exists: false,
        status: 0,
        level: 0,
        label: 'æœªæå‡º',
      };
    }

    return {
      exists: true,
      id: latest.id,
      userId: latest.userId,
      status: latest.status,
      level: latest.status,
      label: this.statusLabel(latest.status),
      documentFront: latest.documentFront,
      documentBack: latest.documentBack,
      createdAt: latest.createdAt,
      updatedAt: latest.updatedAt,
    };
  }

  /**
   * KYCæå‡ºå‡¦ç†
   * front/back ç”»åƒãƒ‘ã‚¹ã‚’DBã«ä¿å­˜
   * status = 1ï¼ˆæå‡ºæ¸ˆã¿ï¼‰
   */
  async submit(userId: number, files: { front: string; back: string }) {
    if (!files.front || !files.back) {
      throw new BadRequestException('front/back ç”»åƒãŒä¸¡æ–¹å¿…è¦ã§ã™ã€‚');
    }

    const kyc = await this.prisma.kycRequest.create({
      data: {
        userId,
        status: 1, // 1 = æå‡ºæ¸ˆã¿
        documentFront: files.front,
        documentBack: files.back,
      },
    });

    return {
      message: 'KYCã‚’æå‡ºã—ã¾ã—ãŸï¼ˆå¯©æŸ»ä¸­ï¼‰ã€‚',
      id: kyc.id,
      userId: kyc.userId,
      status: kyc.status,
      label: this.statusLabel(kyc.status),
      front: kyc.documentFront,
      back: kyc.documentBack,
    };
  }

  /**
   * ç®¡ç†è€…ï¼šå…¨KYCä¸€è¦§
   */
  async listAll() {
    return this.prisma.kycRequest.findMany({
      orderBy: { createdAt: 'desc' },
      include: {
        user: true,
      },
    });
  }

  /**
   * ç®¡ç†è€…ï¼šKYCã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å¤‰æ›´
   * status = 0ã€œ5
   */
  async setStatus(id: number, status: number, reason?: string) {
    const kyc = await this.prisma.kycRequest.findUnique({ where: { id } });
    if (!kyc) {
      throw new NotFoundException('KYCãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    }

    const updated = await this.prisma.kycRequest.update({
      where: { id },
      data: {
        status,
        // documentBack ã«å¦èªç†ç”±ã‚’æš«å®šä¿å­˜ï¼ˆå¿…è¦ãªã‚‰ã‚«ãƒ©ãƒ è¿½åŠ å¯ï¼‰
        documentBack: reason ?? kyc.documentBack,
      },
    });

    return {
      message: 'KYCã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’æ›´æ–°ã—ã¾ã—ãŸ',
      id: updated.id,
      status: updated.status,
      label: this.statusLabel(updated.status),
      reason: reason ?? null,
    };
  }

  /**
   * KYCã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã®ãƒ©ãƒ™ãƒ«
   */
  private statusLabel(status: number): string {
    switch (status) {
      case 0: return 'æœªæå‡º';
      case 1: return 'æå‡ºæ¸ˆã¿';
      case 2: return 'å¯©æŸ»ä¸­';
      case 3: return 'æ‰¿èªã‚¹ãƒ†ãƒƒãƒ—1';
      case 4: return 'å¦èª';
      case 5: return 'KYCå®Œäº†';
      default: return 'UNKNOWN';
    }
  }
}


#############################################
# CATEGORY: prisma
# TYPE: SERVICE
# FILE: prisma.service.ts
# CLASS: PrismaService
#############################################

import { Injectable, OnModuleDestroy, OnModuleInit } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService
  extends PrismaClient
  implements OnModuleInit, OnModuleDestroy
{
  async onModuleInit() {
    await this.$connect();
  }

  async onModuleDestroy() {
    await this.$disconnect();
  }
}




#############################################
# CATEGORY: system
# TYPE: SERVICE
# FILE: system.config.service.ts
# CLASS: SystemConfigService
#############################################

// src/system/system.config.service.ts
import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';

@Injectable()
export class SystemConfigService {
  constructor(private prisma: PrismaService) {}

  /** ã‚°ãƒ«ãƒ¼ãƒ—åˆ¥è¨­å®šå–å¾— */
  async getConfigByGroup(groupId: number) {
    const cfg = await this.prisma.systemTemplate.findFirst({
      where: {
        groupId: groupId,
        name: 'autoTradeConfig',
      },
    });

    if (!cfg) {
      // DB ã«ã¾ã è¨­å®šãŒç„¡ã„ â†’ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã‚’è¿”ã™
      return this.defaultConfig();
    }

    return JSON.parse(cfg.params);
  }

  /** ã‚°ãƒ«ãƒ¼ãƒ—åˆ¥è¨­å®šä¿å­˜ */
  async updateConfigByGroup(groupId: number, newCfg: any) {
    const json = JSON.stringify(newCfg);

    // æ—¢å­˜ã‹ç¢ºèª
    const exists = await this.prisma.systemTemplate.findFirst({
      where: {
        groupId: groupId,
        name: 'autoTradeConfig',
      },
    });

    if (!exists) {
      // æ–°è¦ä½œæˆ
      return this.prisma.systemTemplate.create({
        data: {
          groupId: groupId,
          name: 'autoTradeConfig',
          params: json,
        },
      });
    }

    // æ›´æ–°
    return this.prisma.systemTemplate.update({
      where: { id: exists.id },
      data: { params: json },
    });
  }
/** user.systemStatus ã‚’æ›´æ–°ã™ã‚‹ */
async setUserSystemStatus(
  userId: number,
  status: 'RUNNING' | 'STOP_REQUESTED' | 'STOPPED'
) {
  return this.prisma.user.update({
    where: { id: userId },
    data: { systemStatus: status },
  });
}


  /** ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šï¼ˆåˆæœŸå€¤ï¼‰ */
  defaultConfig() {
    return {
      BTCUSDT: { direction: 'BUY', size: 0.01, holdMinutes: 10, pips: 2, status: 'ACTIVE' },
      ETHUSDT: { direction: 'SELL', size: 0.2, holdMinutes: 15, pips: 1.5, status: 'PENDING' },
      SOLUSDT: { direction: 'BUY', size: 1, holdMinutes: 5, pips: 0.8, status: 'ACTIVE' },
      XRPUSDT: { direction: 'BUY', size: 500, holdMinutes: 8, pips: 0.5, status: 'ACTIVE' },
      BNBUSDT: { direction: 'SELL', size: 0.5, holdMinutes: 12, pips: 2, status: 'ACTIVE' },
      DOGEUSDT: { direction: 'BUY', size: 1000, holdMinutes: 6, pips: 0.3, status: 'PENDING' },
      LTCUSDT: { direction: 'SELL', size: 0.1, holdMinutes: 14, pips: 1.1, status: 'ACTIVE' },
      ADAUSDT: { direction: 'BUY', size: 800, holdMinutes: 9, pips: 0.2, status: 'ACTIVE' },
      AVAXUSDT:{ direction: 'BUY', size: 3, holdMinutes: 7, pips: 1.3, status: 'STOP' },
      DOTUSDT:{ direction: 'SELL', size: 5, holdMinutes: 6, pips: 0.7, status: 'ACTIVE' },
    };
  }
}



#############################################
# CATEGORY: system
# TYPE: SERVICE
# FILE: system.rate.service.ts
# CLASS: SystemRateService
#############################################

// src/system/system.rate.service.ts
import { Injectable } from '@nestjs/common';
import axios from 'axios';

@Injectable()
export class SystemRateService {
  private SPREAD: Record<string, number> = {
    BTCUSDT: 2.5,
    ETHUSDT: 0.5,
    XRPUSDT: 0.02,
    SOLUSDT: 0.2,
    DOTUSDT: 0.2,
    ADAUSDT: 0.01,
    LTCUSDT: 0.3,
    BNBUSDT: 0.5,
  };

  /** Binanceã®ãƒªã‚¢ãƒ«ä¾¡æ ¼ã¸ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚’åŠ æ¸›ã—ã¦æ±ºæ¸ˆä¾¡æ ¼ã‚’ä½œã‚‹ */
  async getFinalClosePrice(symbol: string, side: string): Promise<number> {
    const url = `https://api.binance.com/api/v3/ticker/price?symbol=${symbol}`;

    const res: any = await axios.get(url);
    const market = Number(res.data.price);

    const spread = this.SPREAD[symbol] ?? 0;

    // BUYæ±ºæ¸ˆã¯ Askï¼ˆä¾¡æ ¼ï¼‹ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ï¼‰ã€SELLæ±ºæ¸ˆã¯ Bidï¼ˆä¾¡æ ¼âˆ’ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ï¼‰
    return side === 'BUY' ? market + spread : market - spread;
  }
}




#############################################
# CATEGORY: system
# TYPE: SERVICE
# FILE: system.trade.service.ts
# CLASS: SystemTradeService
#############################################

// src/system/system.trade.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { SystemRateService } from './system.rate.service';

@Injectable()
export class SystemTradeService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly rateService: SystemRateService, // â˜…å¤–éƒ¨ãƒ¬ãƒ¼ãƒˆãƒ»ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰å¯¾å¿œ
  ) {}

  /** è‡ªå‹•ãƒˆãƒ¬ãƒ¼ãƒ‰é–‹å§‹ */
  async autoTrade() {
    const settings = await this.prisma.systemTemplate.findMany({
      where: { name: 'autoTradeConfig' },
    });

    if (!settings.length) return;

    for (const st of settings) {
      const params = JSON.parse(st.params || '{}');
      const groupId = st.groupId;
      await this.runGroupLogic(groupId, params);
    }
  }

  /** ã‚°ãƒ«ãƒ¼ãƒ—è¨­å®šå‡¦ç† */
  private async runGroupLogic(groupId: number, params: any) {
    const symbols = params.symbols || params;

    for (const symbol of Object.keys(symbols)) {
      const conf = symbols[symbol];

      if (!conf || conf.status === 'STOP') continue;

      if (conf.status === 'ACTIVE') {
        await this.openIfNotExists(groupId, symbol, conf);
      }

      if (conf.status === 'PENDING') {
        await this.processPending(groupId, symbol, conf);
      }
    }
  }

  /** ------------------------------
   * ACTIVE â†’ è¦ªï¼‹å­ï¼ˆPAMé…åˆ†ï¼‰ã§æ–°è¦å»ºã¦
   * ------------------------------ */
  private async openIfNotExists(groupId: number, symbol: string, conf: any) {
    const openExists = await this.prisma.trade.findFirst({
      where: {
        groupId,
        symbol,
        closePrice: null,
      },
    });

    if (openExists) return;

    const entryPrice = await this.fakePrice(symbol);

    /** è¦ªå£åº§ OPEN */
    await this.prisma.trade.create({
      data: {
        userId: 9999,
        symbol,
        side: conf.direction,
        size: conf.size,
        entryPrice,
        closePrice: null,
        profit: 0,
        openedAt: new Date(),
        closedAt: null,
        groupId,
      },
    });

    console.log(`[OPEN_PARENT] g${groupId} ${symbol} @ ${entryPrice}`);

    /** â˜… å­å£åº§ã¸PAMãƒ­ãƒƒãƒˆé…åˆ†ã‚³ãƒ”ãƒ¼é–‹å§‹ ----------------------- */

    // groupId ã®å…¨ãƒ¦ãƒ¼ã‚¶ãƒ¼
    const users = await this.prisma.user.findMany({
      where: { groupId },
      include: { wallet: true },
    });

    const children = users.filter((u) => u.id !== 9999);

    // å­å£åº§ã®ç·æ®‹é«˜
    const totalBalance = children.reduce(
      (sum, u) => sum + Number(u.wallet?.balanceTotal ?? 0),
      0,
    );

    if (totalBalance <= 0) {
      console.log(`[WARN] g${groupId} PAMé…åˆ†ï¼šç·æ®‹é«˜ã‚¼ãƒ­ã®ãŸã‚å­å£åº§ã‚³ãƒ”ãƒ¼ã‚’ã‚¹ã‚­ãƒƒãƒ—`);
      return;
    }

    for (const u of children) {
      const userBalance = Number(u.wallet?.balanceTotal ?? 0);

      // è¨¼æ‹ é‡‘æ¯”ç‡
      let userLot = conf.size * (userBalance / totalBalance);

      // ç«¯æ•°åˆ‡ã‚Šæ¨ã¦
      userLot = Math.floor(userLot / 0.01) * 0.01;

      // æœ€ä½ãƒ­ãƒƒãƒˆä¿è¨¼
      if (userLot < 0.01) userLot = 0.01;

      await this.prisma.trade.create({
        data: {
          userId: u.id,
          groupId,
          symbol,
          side: conf.direction,
          size: userLot,
          entryPrice,
          closePrice: null,
          profit: 0,
          openedAt: new Date(),
          closedAt: null,
        },
      });

      console.log(
        `[OPEN_CHILD] g${groupId} user=${u.id} ${symbol} lot=${userLot} @ ${entryPrice}`,
      );
    }

    /** â˜… å­å£åº§PAMã‚³ãƒ”ãƒ¼ã“ã“ã¾ã§ ------------------------------- */
  }

  /** ------------------------------
   * PENDING â†’ æ±ºæ¸ˆå‡¦ç†ï¼ˆæ—§ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
   * ------------------------------ */
  private async processPending(groupId: number, symbol: string, conf: any) {
    const opens = await this.prisma.trade.findMany({
      where: {
        groupId,
        symbol,
        closePrice: null,
      },
    });

    const price = await this.fakePrice(symbol);

    for (const t of opens) {
      const profit =
        conf.direction === 'BUY'
          ? (price - Number(t.entryPrice)) * Number(t.size)
          : (Number(t.entryPrice) - price) * Number(t.size);

      await this.prisma.trade.update({
        where: { id: t.id },
        data: {
          closePrice: price,
          profit,
          closedAt: new Date(),
        },
      });

      console.log(
        `[CLOSE_PENDING] g${groupId} ${symbol} profit=${profit.toFixed(2)}`,
      );
    }
  }

  /** --------------------------
   * Walletãƒ»Userè£œåŠ©é–¢æ•°
   * -------------------------- */
  async getWalletForUser(userId: number) {
    return this.prisma.wallet.findUnique({ where: { userId } });
  }

  async getUserById(userId: number) {
    return this.prisma.user.findUnique({ where: { id: userId } });
  }

  /** ------------------------------
   * è¦ªä¸€æ–‰æ±ºæ¸ˆ â†’ å­å…¨å“¡æ±ºæ¸ˆ
   * ------------------------------ */
  async closePositionsForGroup(groupId: number, symbol?: string) {
    const parentTrades = await this.prisma.trade.findMany({
      where: {
        userId: 9999,
        groupId,
        closePrice: null,
        ...(symbol ? { symbol } : {}),
      },
    });

    for (const p of parentTrades) {
      const closePrice = await this.rateService.getFinalClosePrice(
        p.symbol,
        p.side,
      );

      const parentProfit =
        p.side === 'BUY'
          ? (closePrice - Number(p.entryPrice)) * Number(p.size)
          : (Number(p.entryPrice) - closePrice) * Number(p.size);

      await this.prisma.trade.update({
        where: { id: p.id },
        data: {
          closePrice,
          profit: parentProfit,
          closedAt: new Date(),
        },
      });

      console.log(
        `[CLOSE_PARENT] g${groupId} ${p.symbol} profit=${parentProfit}`,
      );

      /** å­å£åº§ã‚¯ãƒ­ãƒ¼ã‚º */
      const children = await this.prisma.trade.findMany({
        where: {
          groupId,
          userId: { not: 9999 },
          symbol: p.symbol,
          closePrice: null,
        },
      });

      for (const c of children) {
        const profit =
          c.side === 'BUY'
            ? (closePrice - Number(c.entryPrice)) * Number(c.size)
            : (Number(c.entryPrice) - closePrice) * Number(c.size);

        await this.prisma.trade.update({
          where: { id: c.id },
          data: {
            closePrice,
            profit,
            closedAt: new Date(),
          },
        });

        await this.prisma.wallet.update({
          where: { userId: c.userId },
          data: {
            balanceTotal: { increment: profit },
            balanceAvailable: { increment: profit },
          },
        });

        console.log(
          `[CLOSE_CHILD] g${groupId} user=${c.userId} ${c.symbol} profit=${profit}`,
        );
      }
    }
  }

  /** ------------------------------
   * å­å£åº§å€‹åˆ¥æ±ºæ¸ˆ
   * ------------------------------ */
  async closePositionsForUser(userId: number, symbol?: string) {
    const opens = await this.prisma.trade.findMany({
      where: {
        userId,
        closePrice: null,
        ...(symbol ? { symbol } : {}),
      },
    });

    for (const t of opens) {
      const closePrice = await this.rateService.getFinalClosePrice(
        t.symbol,
        t.side,
      );

      const profit =
        t.side === 'BUY'
          ? (closePrice - Number(t.entryPrice)) * Number(t.size)
          : (Number(t.entryPrice) - closePrice) * Number(t.size);

      await this.prisma.trade.update({
        where: { id: t.id },
        data: {
          closePrice,
          profit,
          closedAt: new Date(),
        },
      });

      await this.prisma.wallet.update({
        where: { userId },
        data: {
          balanceTotal: { increment: profit },
          balanceAvailable: { increment: profit },
        },
      });

      console.log(
        `[CLOSE_USER] user=${userId} ${t.symbol} profit=${profit}`,
      );
    }
  }

  /** --------------------------
   * ä»£è¡¨å£åº§ OPENãƒã‚¸ã‚·ãƒ§ãƒ³å–å¾—
   * -------------------------- */
  async getOpenPositionsByGroup(groupId: number) {
    const trades = await this.prisma.trade.findMany({
      where: { groupId, closePrice: null },
      orderBy: { openedAt: 'desc' },
    });

    return trades.map((t) => {
      const currentPrice =
        Number(t.entryPrice) * (1 + (Math.random() - 0.5) * 0.002);

      const pnl =
        t.side === 'BUY'
          ? (currentPrice - Number(t.entryPrice)) * Number(t.size)
          : (Number(t.entryPrice) - currentPrice) * Number(t.size);

      return {
        symbol: t.symbol,
        size: t.size,
        entryPrice: t.entryPrice,
        currentPrice,
        unrealizedPnl: pnl,
        openedAt: t.openedAt,
      };
    });
  }

  /** ç–‘ä¼¼ä¾¡æ ¼ï¼ˆå°†æ¥ã¯å¤–éƒ¨APIã«çµ±åˆï¼‰ */
  private async fakePrice(symbol: string): Promise<number> {
    const base = {
      BTCUSDT: 70000,
      ETHUSDT: 3200,
      SOLUSDT: 150,
      BNBUSDT: 600,
      XRPUSDT: 0.5,
      DOGEUSDT: 0.1,
      LTCUSDT: 90,
      ADAUSDT: 0.7,
      AVAXUSDT: 35,
      DOTUSDT: 8,
    }[symbol] || 100;

    const random = (Math.random() - 0.5) * 0.01 * base;
    return base + random;
  }
}


#############################################
# CATEGORY: tickets
# TYPE: SERVICE
# FILE: tickets.service.ts
# CLASS: TicketsService
#############################################

import { Injectable, ForbiddenException, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { SenderType, TicketStatus } from '@prisma/client';

@Injectable()
export class TicketsService {
  constructor(private readonly prisma: PrismaService) {}

  async listMyTickets(userId: number) {
    return this.prisma.ticket.findMany({
      where: { userId },
      orderBy: { createdAt: 'desc' },
    });
  }

  async createTicket(userId: number, title: string, message: string) {
    return this.prisma.$transaction(async (tx) => {
      const ticket = await tx.ticket.create({
        data: {
          userId,
          title,
          status: TicketStatus.OPEN,
        },
      });

      await tx.ticketMessage.create({
        data: {
          ticketId: ticket.id,
          sender: SenderType.USER,
          message,
        },
      });

      return ticket;
    });
  }

  async replyToTicketAsUser(userId: number, ticketId: number, message: string) {
    const ticket = await this.prisma.ticket.findUnique({ where: { id: ticketId } });
    if (!ticket) throw new NotFoundException('Ticket not found');
    if (ticket.userId !== userId) throw new ForbiddenException('Not your ticket');

    return this.prisma.ticketMessage.create({
      data: {
        ticketId,
        sender: SenderType.USER,
        message,
      },
    });
  }

  async listAllTickets() {
    return this.prisma.ticket.findMany({
      orderBy: { createdAt: 'desc' },
    });
  }

  async replyAsAdmin(ticketId: number, message: string) {
    return this.prisma.ticketMessage.create({
      data: {
        ticketId,
        sender: SenderType.ADMIN,
        message,
      },
    });
  }

  async setStatus(ticketId: number, status: TicketStatus) {
    return this.prisma.ticket.update({
      where: { id: ticketId },
      data: { status },
    });
  }

  async getTicketMessages(ticketId: number) {
    return this.prisma.ticketMessage.findMany({
      where: { ticketId },
      orderBy: { createdAt: 'asc' },
    });
  }
}


#############################################
# CATEGORY: user-extra
# TYPE: SERVICE
# FILE: user-bank.service.ts
# CLASS: UserBankService
#############################################

import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { SaveBankDto } from './dto/save-bank.dto';

@Injectable()
export class UserBankService {
  constructor(private prisma: PrismaService) {}

  async getBankAccount(userId: number) {
    return this.prisma.userBankAccount.findUnique({ where: { userId } });
  }

  async saveBankAccount(userId: number, dto: SaveBankDto) {
    return this.prisma.userBankAccount.upsert({
      where: { userId },
      create: { userId, ...dto },
      update: { ...dto, updatedAt: new Date() },
    });
  }
}


#############################################
# CATEGORY: user-extra
# TYPE: SERVICE
# FILE: user-crypto.service.ts
# CLASS: UserCryptoService
#############################################

import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { SaveCryptoDto } from './dto/save-crypto.dto';
import { UserCryptoAddress } from '@prisma/client';

@Injectable()
export class UserCryptoService {
  constructor(private readonly prisma: PrismaService) {}

  /** ã™ã¹ã¦å–å¾— */
  async getList(userId: number): Promise<UserCryptoAddress[]> {
    return this.prisma.userCryptoAddress.findMany({
      where: { userId },
    });
  }

  /** è¤‡æ•°ã‚¢ãƒ‰ãƒ¬ã‚¹ä¿å­˜ï¼ˆUPSERTï¼‰ */
  async saveList(
    userId: number,
    dto: SaveCryptoDto
  ): Promise<UserCryptoAddress[]> {

    // âœ… å‹ã‚’æ˜ç¤ºï¼ˆè¶…é‡è¦ï¼‰
    const results: UserCryptoAddress[] = [];

    for (const c of dto.addresses) {
      const saved = await this.prisma.userCryptoAddress.upsert({
        where: {
          userId_currency: {
            userId,
            currency: c.currency,
          },
        },
        update: {
          address: c.address,
          memoTag: c.memoTag ?? null,
        },
        create: {
          userId,
          currency: c.currency,
          address: c.address,
          memoTag: c.memoTag ?? null,
        },
      });

      results.push(saved); // âœ… ã‚¨ãƒ©ãƒ¼ãªã—
    }

    return results;
  }
}


#############################################
# CATEGORY: users
# TYPE: SERVICE
# FILE: users.service.ts
# CLASS: UsersService
#############################################

import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { UserRole } from '@prisma/client';

@Injectable()
export class UsersService {
  constructor(private readonly prisma: PrismaService) {}

  async findByEmail(email: string) {
  return this.prisma.user.findUnique({
    where: { email },
    select: {
      id: true,
      email: true,
      password: true,      // â† â˜…ã“ã‚ŒãŒãªã„ã¨çµ¶å¯¾ã«ãƒ­ã‚°ã‚¤ãƒ³ã§ããªã„
      name: true,
      role: true,
      systemStatus: true,
      wallet: true,
      group: true,
    },
  });
}


  async createUser(params: {
    email: string;
    password: string;
    name: string;
    role?: UserRole;
  }) {
    const { email, password, name, role = UserRole.USER } = params;

    return this.prisma.$transaction(async (tx) => {
      // Prisma ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’ any ã¨ã—ã¦æ‰±ã£ã¦å‹ã‚¨ãƒ©ãƒ¼ã‚’é¿ã‘ã‚‹
      const client = tx as any;

      const user = await client.user.create({
        data: {
          email,
          password: password,
          name,
          role,
        },
      });

      await client.wallet.create({
        data: {
          userId: user.id,
          balanceTotal: 0,
          balanceAvailable: 0,
          balanceLocked: 0,
        },
      });

      return user;
    });
  }

  async findById(id: number) {
    return this.prisma.user.findUnique({
      where: { id },
      include: { wallet: true, group: true },
    });
  }
}


#############################################
# CATEGORY: wallet
# TYPE: SERVICE
# FILE: wallet.service.ts
# CLASS: WalletService
#############################################

import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';

@Injectable()
export class WalletService {
  constructor(private readonly prisma: PrismaService) {}

  async getWalletWithHistory(userId: number) {
    const wallet = await this.prisma.wallet.findUnique({
      where: { userId },
    });

    if (!wallet) {
      throw new NotFoundException('Wallet not found');
    }

    const transfers = await this.prisma.transfer.findMany({
      where: { userId },
      orderBy: { createdAt: 'desc' },
      take: 50,
    });

    return { wallet, transfers };
  }
}


#############################################
# CATEGORY: withdraw
# TYPE: SERVICE
# FILE: withdraw.service.ts
# CLASS: WithdrawService
#############################################

import {
  BadRequestException,
  Injectable,
  NotFoundException,
} from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { TransferStatus, TransferType } from '@prisma/client';

@Injectable()
export class WithdrawService {
  constructor(private readonly prisma: PrismaService) {}

  /**
   * å‡ºé‡‘ç”³è«‹ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ï¼‰
   *
   * ãƒ«ãƒ¼ãƒ«ï¼š
   * - KYC status = 5 ã®ã¿å‡ºé‡‘å¯èƒ½
   * - æ®‹é«˜ä¸è¶³ã¯æ‹’å¦
   * - ç”³è«‹æ™‚ã« available â†’ locked
   */
  async requestWithdraw(userId: number, amount: number) {
    /* ---------- KYCãƒã‚§ãƒƒã‚¯ ---------- */
    const kyc = await this.prisma.kycRequest.findFirst({
      where: { userId },
      orderBy: { createdAt: 'desc' },
    });

    if (!kyc) {
      throw new BadRequestException(
        'å‡ºé‡‘ã«ã¯KYCæå‡ºãŒå¿…è¦ã§ã™ã€‚'
      );
    }

    if (kyc.status !== 5) {
      throw new BadRequestException(
        'KYCãŒå®Œäº†ã—ã¦ã„ã¾ã›ã‚“ã€‚å‡ºé‡‘å¯èƒ½ãªã®ã¯ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹5ï¼ˆå®Œäº†ï¼‰ã®ã¿ã§ã™ã€‚'
      );
    }

    /* ---------- ã‚¦ã‚©ãƒ¬ãƒƒãƒˆ ---------- */
    const wallet = await this.prisma.wallet.findUnique({
      where: { userId },
    });
    if (!wallet) throw new NotFoundException('Wallet not found');

    if (amount <= 0) {
      throw new BadRequestException('Amount must be positive');
    }

    if (Number(wallet.balanceAvailable) < amount) {
      throw new BadRequestException('Insufficient available balance');
    }

    /* ---------- å‡ºé‡‘ç”³è«‹ ---------- */
    return this.prisma.$transaction(async (tx) => {
      const transfer = await tx.transfer.create({
        data: {
          userId,
          type: TransferType.WITHDRAW,
          amount: amount.toString(),
          status: TransferStatus.PENDING,
        },
      });

      await tx.wallet.update({
        where: { userId },
        data: {
          balanceAvailable: { decrement: amount },
          balanceLocked: { increment: amount },
        },
      });

      return transfer;
    });
  }

  /**
   * Pendingå‡ºé‡‘ä¸€è¦§ï¼ˆAdminï¼‰
   */
  async listPendingWithdraws() {
    return this.prisma.transfer.findMany({
      where: {
        type: TransferType.WITHDRAW,
        status: TransferStatus.PENDING,
      },
      orderBy: { createdAt: 'asc' },
    });
  }

  /**
   * å‡ºé‡‘æ‰¿èªï¼ˆAdminï¼‰
   */
  async approveWithdraw(transferId: number) {
  const transfer = await this.prisma.transfer.findUnique({
    where: { id: transferId },
  });

  if (!transfer || transfer.type !== TransferType.WITHDRAW) {
    throw new NotFoundException('Withdraw request not found');
  }

  if (transfer.status !== TransferStatus.PENDING) {
    throw new BadRequestException('Withdraw is not pending');
  }

  return this.prisma.$transaction(async (tx) => {
    /* ---------- å‡ºé‡‘å®Œäº† ---------- */
    const updatedTransfer = await tx.transfer.update({
      where: { id: transferId },
      data: { status: TransferStatus.COMPLETED },
    });

    await tx.wallet.update({
      where: { userId: transfer.userId },
      data: {
        balanceLocked: { decrement: transfer.amount },
        balanceTotal: { decrement: transfer.amount },
      },
    });

    /* ---------- ãƒãƒ£ãƒƒãƒˆé€ä¿¡ï¼ˆå‡ºé‡‘æ‰¿èªï¼‰ ---------- */
    let ticket = await tx.ticket.findFirst({
      where: {
        userId: transfer.userId,
        status: 'OPEN',
      },
    });

    if (!ticket) {
      ticket = await tx.ticket.create({
        data: {
          userId: transfer.userId,
          title: 'å‡ºé‡‘ã«é–¢ã™ã‚‹ã”é€£çµ¡',
          status: 'OPEN',
        },
      });
    }

    await tx.ticketMessage.create({
      data: {
        ticketId: ticket.id,
        sender: 'ADMIN',
        message: `
å‡ºé‡‘ç”³è«‹ãŒæ‰¿èªã•ã‚Œã¾ã—ãŸã€‚

æŒ‡å®šã•ã‚ŒãŸå‡ºé‡‘å…ˆã¸é€é‡‘å‡¦ç†ã‚’é€²ã‚ã¦ãŠã‚Šã¾ã™ã€‚
åæ˜ ã¾ã§ä»Šã—ã°ã‚‰ããŠå¾…ã¡ãã ã•ã„ã€‚
        `.trim(),
      },
    });

    return updatedTransfer;
  });
}


  /**
   * ç®¡ç†å´ï¼šå‡ºé‡‘ã‚­ãƒ£ãƒ³ã‚»ãƒ«
   * - å‡ºé‡‘ã‚­ãƒ£ãƒ³ã‚»ãƒ«
   * - KYC status = 4ï¼ˆè¿½åŠ èªè¨¼ï¼‰
   * - ãƒãƒ£ãƒƒãƒˆè‡ªå‹•é€šçŸ¥
   */
  async cancelWithdrawWithKycRollback(transferId: number) {
    const transfer = await this.prisma.transfer.findUnique({
      where: { id: transferId },
    });

    if (!transfer || transfer.type !== TransferType.WITHDRAW) {
      throw new NotFoundException('Withdraw request not found');
    }

    if (transfer.status !== TransferStatus.PENDING) {
      throw new BadRequestException('Withdraw is not pending');
    }

    const kyc = await this.prisma.kycRequest.findFirst({
      where: { userId: transfer.userId },
      orderBy: { createdAt: 'desc' },
    });

    return this.prisma.$transaction(async (tx) => {
      /* ---------- å‡ºé‡‘ã‚­ãƒ£ãƒ³ã‚»ãƒ« ---------- */
      await tx.transfer.update({
        where: { id: transferId },
        data: { status: TransferStatus.CANCELED },
      });

      await tx.wallet.update({
        where: { userId: transfer.userId },
        data: {
          balanceLocked: { decrement: transfer.amount },
          balanceAvailable: { increment: transfer.amount },
        },
      });

      /* ---------- KYC å·®ã—æˆ»ã— ---------- */
      if (kyc) {
        await tx.kycRequest.update({
          where: { id: kyc.id },
          data: { status: 4 },
        });
      }

      /* ---------- ãƒãƒ£ãƒƒãƒˆé€šçŸ¥ ---------- */
      let ticket = await tx.ticket.findFirst({
        where: {
          userId: transfer.userId,
          status: 'OPEN',
        },
      });

      if (!ticket) {
        ticket = await tx.ticket.create({
          data: {
            userId: transfer.userId,
            title: 'å‡ºé‡‘ã«é–¢ã™ã‚‹ã”é€£çµ¡',
            status: 'OPEN',
          },
        });
      }

      await tx.ticketMessage.create({
        data: {
          ticketId: ticket.id,
          sender: 'ADMIN',
          message: `
å‡ºé‡‘ç”³è«‹ã®å†…å®¹ã«ç¢ºèªäº‹é …ãŒã‚ã‚Šã€
è¿½åŠ ã®æœ¬äººç¢ºèªãŒå¿…è¦ã¨ãªã‚Šã¾ã—ãŸã€‚

ãŠæ‰‹æ•°ã§ã™ãŒã€
KYCï¼ˆæœ¬äººç¢ºèªï¼‰ã®å†æå‡ºã‚’ãŠé¡˜ã„ã„ãŸã—ã¾ã™ã€‚

ç¢ºèªå®Œäº†å¾Œã€å†åº¦å‡ºé‡‘ç”³è«‹ãŒå¯èƒ½ã«ãªã‚Šã¾ã™ã€‚
          `.trim(),
        },
      });

      return { success: true };
    });
  }
}


